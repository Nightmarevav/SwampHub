# Руководство по описанию прикладной архитектуры ГК Болото

## Введение

Согласно [методологии описания корпоративной архитектуры ГК Болото](/docs/arch_introduction) данное руководство касается только описания архитектуры уровней ПА-L1 (общая прикладная архитектура) и ПА-L2 (прикладная архитектура проектов).


## Правила описания прикладной архитектуры компании в DocHub

В данном разделе описаны основные правила описания прикладной архитектуры в DocHub. При этом нужно учитывать, что инструмент DocHub постоянно развивается и часть информации может быть неактуальной. С целью минимизации таких ситуаций описание происходит на достаточно высоком уровне. 


Помимо указанного выше видео есть [сайт разработчика DocHub](https://dochub.info) где можно посмотреть примеры использования инструмента и подробно ознакомиться с его возможностями.

### Правила описания прикладной архитектуры компании уровня ПА-L1

#### Структура данных для управления системами

Описание репозитория можно найти [здесь](/docs/dochub_app_repo_guide).


#### Правила именования объектов связанных с системами

1. Все имена, названия и код должны писаться в нотации [snake_case](https://ru.wikipedia.org/wiki/Snake_case)
2. Имя yaml файла описывающего конкретную систему должно соответствовать имени системы внутри идентификатора системы (см. п.3)
3. Идентификатор системы в общем случае представляет из себя доменное имя в виде:
`swamp.<имя бизнес-юнита>.<имя системы>`



### Правила описания прикладной архитектуры компании уровня ПА-L2

Для описания run-time компонент системы есть 2 пути:
1. Описать run-time компоненты системы внутри общего репозитория swamp
2. Описать run-time компоненты системы внутри собственного репозитория системы

С точки зрения конечных данных оба варианта равнозначны и выбор только за вами.

**Советы по выбору варианта**
1. Если вы один архитектор управляющий несколькими системами, то удобней управлять архитектурой своих приложений в общем репозитории Swamp.
2. Если у вас одна система, которая "живет" в своем репозитории, то возможно вам будет удобнее управлять архитектурой из репозитория системы.
3. Если у вас внешняя система для которой нужно описать run-time компоненты, то описывать их нужно в общем репозитории Swamp


### Правила отображения связей между системами

#### Как понять в какую сторону отобразить стрелку при указании связи систем

В зависимости от уровня абстракции ситуация может выглядеть по-разному. Например, спускаясь на технический уровень практически в 100% случаев нам придется отобразить двухстороннюю связь между системами.

В первую очередь, это связанно с тем, что при технической реализации системе-приёмнику необходимо выполнить какое-либо действие или набор действий для того, чтобы получить данные. Поэтому использовать этот уровень абстракции логическом уровне ПА-L1 не имеет физического смысла.

Для того чтобы корректно отобразить стрелку при указании связи систем мы рекомендуем задать вопрос: "В какую систему приходят конечные бизнес-данные, от которых зависит бизнес-процесс?".

Ответ на этот вопрос, в большинстве случаев даст вам однозначное понимание какая система отправляет данные, а какая получает их. Например, в примере описанном в разделе [&#34;Как правильно отобразить стрелки, если системы отправляют данные друг другу?&#34;](#как-правильно-отобразить-стрелки-если-системы-отправляют-данные-друг-другу) описана ситуация, когда есть два набора бизнес-данных которые отправляются из S.CEC в 1С Бит.Финанс и наоборот. Т.е. по факту есть два топика в Kafka с разной бизнес-информацией от которой зависит логическая раота каждой из систем.

#### Как правильно отобразить стрелки, если системы отправляют данные друг другу?

В связи с тем, что описывать системы и их взаимосвязи могут разные сотрудники, то при отображении связей между системами можно задублировать их связи. Для решения этой проблемы необходимо пользоваться следующим правилом:

- В карточке системы должен отображаться только входящий поток данных `direction: <--`.

Например, у вас есть две системы 1С Бит.Финанс (БЮ Frog) и S.CEC (БЮ Crocodile). Обе эти системы получают данные и отправляют их друг другу.
Согласно вышеописанному правилу при описании системы 1С Бит.Финанс вы должны отобразить только факт получения данных из S.CEC.

```yaml
components:
    swamp.frog.1cbit_finance:
        title: 1С Бит.Финанс
    links:
        - id: swamp.crocodile.sgovernance.scec
          direction: <-- # Входящий поток данных в 1С Бит.Финанс из S.CEC
```

То же самое вы должны сделать при описании системы S.CEC

```yaml
components:
    swamp.crocodile.sgovernance.scec:
        title: S.CEC
    links:
        - id: swamp.frog.1cbit_finance.1cbit_finance
          direction: <-- # Входящий поток данных в S.CEC из 1С Бит.Финанс
```
